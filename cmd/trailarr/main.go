package main

import (
	"context"
	"os"
	"path/filepath"
	"strings"
	"trailarr/internal"

	"github.com/gin-gonic/gin"
)

var timings map[string]int

func main() {
	// Only log backend/server logs to file. Gin (frontend HTTP) logs go to stdout only.
	logDir := internal.LogsDir
	logFile := logDir + "/trailarr.txt"
	_ = os.MkdirAll(logDir, 0775)
	internal.InitTrailarrLogWriter(logFile)
	gin.DefaultWriter = os.Stdout
	gin.DefaultErrorWriter = os.Stderr

	// Check store compatibility layer at startup (now backed by bbolt).
	// Do not fail startup if the backend is not reachable; fall back to BoltDB in-memory
	// or on-disk implementations provided by the codebase.
	if err := internal.PingStore(context.Background()); err != nil {
		internal.TrailarrLog(internal.WARN, "Startup", "Store backend not reachable; continuing with BoltDB/mem fallback: %v", err)
	} else {
		internal.TrailarrLog(internal.INFO, "Startup", "Store compatibility layer ready (using BoltDB)")
	}

	// Clean up yt-dlp-tmp directories at startup
	cleanYTDLPTmpDirs()

	// Ensure cookies.txt exists and is in Netscape format
	cookiesPath := internal.CookiesFile
	ensureNetscapeCookiesFile(cookiesPath)
	// Ensure config.yml exists and is filled with defaults
	_ = internal.EnsureConfigDefaults()
	// Load config.yml into memory
	if err := internal.LoadConfig(); err != nil {
		internal.TrailarrLog(internal.WARN, "Startup", "Could not load config.yml: %v", err)
	}

	var err error
	timings, err = internal.EnsureSyncTimingsConfig()
	if err != nil {
		internal.TrailarrLog(internal.WARN, "Startup", "Could not load sync timings: %v", err)
	}
	internal.Timings = timings
	internal.TrailarrLog(internal.INFO, "Startup", "Sync timings: %v", timings)

	// Load last task run times (store primary, disk fallback)
	if _, err := internal.LoadTaskStates(); err != nil {
		internal.TrailarrLog(internal.WARN, "Startup", "Could not load last task run times: %v", err)
	}
	internal.TrailarrLog(internal.DEBUG, "Startup", "Loaded GlobalTaskStates: %+v", internal.GlobalTaskStates)
	r := gin.Default()
	// Configure trusted proxies to avoid Gin warning about trusting all proxies.
	if proxies, err := internal.GetTrustedProxies(); err == nil {
		if err2 := r.SetTrustedProxies(proxies); err2 != nil {
			internal.TrailarrLog(internal.WARN, "Startup", "Failed to set trusted proxies: %v", err2)
		} else {
			internal.TrailarrLog(internal.INFO, "Startup", "Set TrustedProxies: %v", strings.Join(proxies, ","))
		}
	} else {
		internal.TrailarrLog(internal.WARN, "Startup", "Unable to read trusted proxies config; using default loopback only: %v", err)
	}
	internal.RegisterRoutes(r)
	go internal.StartBackgroundTasks()
	r.Run(":8080")
}

// cleanYTDLPTmpDirs removes all yt-dlp-tmp-* directories from /tmp
func cleanYTDLPTmpDirs() {
	tmpDir := "/tmp"
	entries, err := os.ReadDir(tmpDir)
	if err != nil {
		return
	}
	for _, entry := range entries {
		if entry.IsDir() && strings.HasPrefix(entry.Name(), "yt-dlp-tmp-") {
			os.RemoveAll(filepath.Join(tmpDir, entry.Name()))
		}
	}
}

// ensureNetscapeCookiesFile creates a valid Netscape-format cookies.txt if missing or empty
func ensureNetscapeCookiesFile(path string) {
	fi, err := os.Stat(path)
	if err == nil && fi.Size() > 0 {
		// File exists and is not empty
		return
	}
	// Ensure parent directory exists
	dir := filepath.Dir(path)
	_ = os.MkdirAll(dir, 0755)
	content := "# Netscape HTTP Cookie File\n# This file was generated by Trailarr\n"
	_ = os.WriteFile(path, []byte(content), 0644)
}
